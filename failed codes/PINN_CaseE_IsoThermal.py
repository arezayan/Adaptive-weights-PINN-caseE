# -*- coding: utf-8 -*-
"""
PINN_CaseE_3D_isoThermal

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wCDteXZB6Bvb_kV5uYGBjIVrAjzkkxJY
For cas E
@author: Amirreza
"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time

# Check if CUDA is available
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

"""# **Define Network | Physics-informed**"""

class PINN(nn.Module):
    def __init__(self, layers):
        super(PINN, self).__init__()
        self.layers = nn.ModuleList()

        for i in range(len(layers) - 1):
            layer = nn.Linear(layers[i], layers[i + 1])
            nn.init.xavier_uniform_(layer.weight)  # Xavier initialization for weights
            nn.init.zeros_(layer.bias)             # Initialize biases to zero
            self.layers.append(layer)

    def forward(self, x):
        for i in range(len(self.layers) - 1):
            x = torch.relu(self.layers[i](x))
        x = self.layers[-1](x)
        return x

# Define the network architecture
#layers = [3, 40, 40, 40, 40, 40, 40, 40, 4]  # Input: (x, y), Output: (u, v, p)
layers = [3, 200, 200, 200, 200, 200, 200, 200, 4]  # Input: (x, y), Output: (u, v, p)
model = PINN(layers).to(device)

"""# **Define Desired PDE**"""

def navier_stokes_loss(model, x, y, z, mu, lambda_momentum, lambda_continuity):
    x = x.requires_grad_(True)
    y = y.requires_grad_(True)
    z = z.requires_grad_(True)

    uvp = model(torch.cat((x, y, z), dim=1))
    u = uvp[:, 0:1]
    v = uvp[:, 1:2]
    w = uvp[:, 2:3]
    p = uvp[:, 3:4]

    # Calculate gradients
    u_x = torch.autograd.grad(u, x, grad_outputs=torch.ones_like(u), create_graph=True)[0]
    u_y = torch.autograd.grad(u, y, grad_outputs=torch.ones_like(u), create_graph=True)[0]
    u_z = torch.autograd.grad(u, z, grad_outputs=torch.ones_like(u), create_graph=True)[0]

    v_x = torch.autograd.grad(v, x, grad_outputs=torch.ones_like(v), create_graph=True)[0]
    v_y = torch.autograd.grad(v, y, grad_outputs=torch.ones_like(v), create_graph=True)[0]
    v_z = torch.autograd.grad(v, z, grad_outputs=torch.ones_like(v), create_graph=True)[0]

    w_x = torch.autograd.grad(w, x, grad_outputs=torch.ones_like(w), create_graph=True)[0]
    w_y = torch.autograd.grad(w, y, grad_outputs=torch.ones_like(w), create_graph=True)[0]
    w_z = torch.autograd.grad(w, z, grad_outputs=torch.ones_like(w), create_graph=True)[0]

    u_xx = torch.autograd.grad(u_x, x, grad_outputs=torch.ones_like(u_x), create_graph=True)[0]
    u_yy = torch.autograd.grad(u_y, y, grad_outputs=torch.ones_like(u_y), create_graph=True)[0]
    u_zz = torch.autograd.grad(u_z, z, grad_outputs=torch.ones_like(u_z), create_graph=True)[0]

    v_xx = torch.autograd.grad(v_x, x, grad_outputs=torch.ones_like(v_x), create_graph=True)[0]
    v_yy = torch.autograd.grad(v_y, y, grad_outputs=torch.ones_like(v_y), create_graph=True)[0]
    v_zz = torch.autograd.grad(v_z, z, grad_outputs=torch.ones_like(v_z), create_graph=True)[0]

    w_xx = torch.autograd.grad(w_x, x, grad_outputs=torch.ones_like(w_x), create_graph=True)[0]
    w_yy = torch.autograd.grad(w_y, y, grad_outputs=torch.ones_like(w_y), create_graph=True)[0]
    w_zz = torch.autograd.grad(w_z, z, grad_outputs=torch.ones_like(w_z), create_graph=True)[0]

    p_x = torch.autograd.grad(p, x, grad_outputs=torch.ones_like(p), create_graph=True)[0]
    p_y = torch.autograd.grad(p, y, grad_outputs=torch.ones_like(p), create_graph=True)[0]
    p_z = torch.autograd.grad(p, z, grad_outputs=torch.ones_like(p), create_graph=True)[0]

    # Navier-Stokes equations

    f_u = u*u_x + v*u_y + w*u_z + p_x - mu * (u_xx + u_yy + u_zz)
    f_v = u*v_x + v*v_y + w*v_z + p_y - mu * (v_xx + v_yy + v_zz)
    f_w = u*w_x + v*w_y + w*w_z + p_z - mu * (w_xx + w_yy + w_zz)

    # Continuity equation
    continuity = u_x + v_y + w_z

    # Loss calculation with balancing factors
    loss_f = (lambda_momentum * (torch.mean(f_u**2) + torch.mean(f_v**2)+ torch.mean(f_w**2)) +
              lambda_continuity * torch.mean(continuity**2))
    return loss_f

def boundary_condition_loss(model, x_b, y_b, z_b, u_b, v_b, w_b, p_b=None):
    uvp_b = model(torch.cat((x_b, y_b, z_b), dim=1))
    u_b_pred = uvp_b[:, 0:1]
    v_b_pred = uvp_b[:, 1:2]
    w_b_pred = uvp_b[:, 2:3]
    p_b_pred = uvp_b[:, 3:4]

    loss_u_b = torch.mean((u_b_pred - u_b) ** 2)
    loss_v_b = torch.mean((v_b_pred - v_b) ** 2)
    loss_w_b = torch.mean((w_b_pred - w_b) ** 2)
    loss_p_b = torch.mean((p_b_pred - p_b) ** 2)

    return loss_u_b + loss_v_b + loss_w_b #+ loss_p_b

def data_loss(model,x,y,z, u_exact, v_exact, w_exact, p_exact=None):
    uvp_pred = model(torch.cat((x, y, z), dim=1))
    u_pred = uvp_pred[:, 0:1]
    v_pred = uvp_pred[:, 1:2]
    w_pred = uvp_pred[:, 2:3]
    p_pred = uvp_pred[:, 3:4] if p_exact is not None else None

    loss_u = torch.mean((u_pred - u_exact) ** 2)
    loss_v = torch.mean((v_pred - v_exact) ** 2)
    loss_w = torch.mean((w_pred - w_exact) ** 2)
    loss_p = torch.mean((p_pred - p_exact) ** 2) if p_exact is not None else 0

    return loss_u + loss_v + loss_w + (loss_p if p_exact is not None else 0)

def total_loss(model, x_data, y_data, z_data, u_exact, v_exact,w_exact,p_exact, mu, x_b , y_b, z_b, u_b, v_b, w_b,p_b,
               lambda_momentum, lambda_continuity, lambda_data, lambda_bc):

    uvp_pred = model(torch.cat((x_data, y_data, z_data), dim=1))

    # Physics-informed loss
    loss_f = navier_stokes_loss(model, x, y, z, mu, lambda_momentum, lambda_continuity)

    # Data loss
    loss_data = data_loss(model, x, y, z, u_exact, v_exact, w_exact, p_exact) * lambda_data

    # Boundary condition loss
    loss_bc = boundary_condition_loss(model, x_b, y_b,z_b, u_b, v_b,w_b, p_b) * lambda_bc if x_b is not None else 0

    return loss_f + loss_data + loss_bc

# Load data from CSV
data = pd.read_csv('caseE_Data.csv')
data = (data - data.min()) / (data.max() - data.min())
data['z'] = 2
data['v'] = data['w'] = 0
x = torch.tensor(data[['x']][:30].values, dtype=torch.float32).to(device)
y = torch.tensor(data[['y']][:30].values, dtype=torch.float32).to(device)
z = torch.tensor(data[['z']][:30].values, dtype=torch.float32).to(device)
u_exact = torch.tensor(data[['u']][:30].values, dtype=torch.float32).to(device)
v_exact = torch.tensor(data[['v']][:30].values, dtype=torch.float32).to(device)
w_exact = torch.tensor(data[['w']][:30].values, dtype=torch.float32).to(device)
p_exact = torch.tensor(data[['p']][:30].values, dtype=torch.float32).to(device) if 'p' in data.columns else None



# Example boundary data (you may need to replace this with actual data)

bc_data = pd.read_csv('caseE_BC.csv')
bc_data = (bc_data - bc_data.min()) / (bc_data.max() - bc_data.min())
bc_data['u'] = bc_data['v'] = bc_data['w'] = 0
x_b = (torch.tensor(bc_data['x'], dtype=torch.float32).to(device)).reshape(-1,1)
y_b = (torch.tensor(bc_data['y'], dtype=torch.float32).to(device)).reshape(-1,1)
z_b = (torch.tensor(bc_data['z'], dtype=torch.float32).to(device)).reshape(-1,1)
u_b = (torch.tensor(bc_data['u'], dtype=torch.float32).to(device)).reshape(-1,1)  # Boundary u-values
v_b = (torch.tensor(bc_data['v'], dtype=torch.float32).to(device)).reshape(-1,1)  # Boundary v-values
w_b = (torch.tensor(bc_data['w'], dtype=torch.float32).to(device)).reshape(-1,1)  # Boundary w-values
p_b = (torch.tensor(bc_data['p'], dtype=torch.float32).to(device)).reshape(-1,1)  # Boundary w-values
"""
### LBFGS optimizer

# Training parameters
epochs = 25000
mu = 0.01  # Dynamic viscosity
lambda_momentum = 1
lambda_continuity = 1
lambda_data = 1
lambda_bc = 1

# Define the optimizer
optimizer = optim.LBFGS(model.parameters(), lr=0.1)#, max_iter=500, history_size=10)

for epoch in range(epochs):
    model.train()

    def closure():
        optimizer.zero_grad()
        loss = total_loss(model, x, y, z, u_exact, v_exact, w_exact, p_exact, mu, x_b, y_b, z_b, u_b, v_b, w_b, p_b,
                          lambda_momentum, lambda_continuity, lambda_data, lambda_bc)
        loss.backward()
        return loss  # Return the loss for the optimizer to use

    loss = optimizer.step(closure)  # The optimizer calls closure and gets the loss

    if epoch % 250 == 0:
        print(f'Epoch {epoch}, Total Loss: {loss.item()}')
        #print(time.time())

model.eval()
with torch.no_grad():
    uvp_pred = model(torch.cat((x, y, z), dim=1))
    u_pred = uvp_pred[:, 0:1]
    v_pred = uvp_pred[:, 1:2]
    w_pred = uvp_pred[:, 2:3]
    p_pred = uvp_pred[:, 3:4]
"""
# Training parameters with Adam Optimizers
epochs = 25000
mu = 0.01  # Dynamic viscosity
lambda_momentum = 1
lambda_continuity = 1
lambda_data = 1
lambda_bc = 1
learning_rate = 1e-5

# Define the optimizer
optimizer = optim.Adam(model.parameters(), lr=learning_rate, betas = (0.9,0.99),eps = 10**-15)

for epochs in range(epochs):
    model.train()
    optimizer.zero_grad()

    loss = total_loss(model, x, y, z, u_exact, v_exact, w_exact,p_exact,mu,  x_b , y_b, z_b, u_b, v_b, w_b,p_b,
                      lambda_momentum, lambda_continuity, lambda_data, lambda_bc)
    loss.backward()
    optimizer.step()

    if epochs % 100 == 0:
        print(f'Epoch {epochs}, Total Loss: {loss.item()}')
        #print(time.time())

model.eval()
with torch.no_grad():
    uvp_pred = model(torch.cat((x, y, z), dim=1))
    u_pred = uvp_pred[:, 0:1]
    v_pred = uvp_pred[:, 1:2]
    w_pred = uvp_pred[:, 2:3]
    p_pred = uvp_pred[:, 3:4]

# Convert tensors to numpy arrays
x_train_np = x.detach().numpy()
y_train_np = y.detach().numpy()
z_train_np = z.detach().numpy()
u_exact_np = u_exact.detach().numpy()
v_exact_np = v_exact.detach().numpy()
w_exact_np = w_exact.detach().numpy()
p_exact_np = p_exact.detach().numpy()

uvp_pred = model(torch.cat((x, y, z), dim=1))
u_pred = uvp_pred[:, 0:1]
v_pred = uvp_pred[:, 1:2]
w_pred = uvp_pred[:, 2:3]
p_pred = uvp_pred[:, 3:4] if p_exact is not None else None

u_pred_np = u_pred.detach().numpy()
v_pred_np = v_pred.detach().numpy()
w_pred_np = w_pred.detach().numpy()
p_pred_np = p_pred.detach().numpy()

plt.figure(dpi = 150)
plt.plot(u_exact_np, label='Exact u', marker='o')
plt.plot(u_pred_np, label='Predicted u', marker='x')
plt.legend()
plt.title('Comparison of u component')


# Plotting the results
plt.figure(figsize=(20, 5))

plt.subplot(1, 3, 1)
plt.scatter(x_train_np, y_train_np, c=u_exact_np, label='Exact u', marker='o')
plt.scatter(x_train_np, y_train_np, c=u_pred_np, label='Predicted u', marker='x')
plt.legend()
plt.colorbar()
plt.title('Comparison of u component')

plt.subplot(1, 3, 2)
plt.scatter(x_train_np, y_train_np, c=v_exact_np, label='Exact v', marker='o')
plt.scatter(x_train_np, y_train_np, c=v_pred_np, label='Predicted v', marker='x')
plt.legend()
plt.colorbar()
plt.title('Comparison of v component')

plt.subplot(1, 3, 3)
plt.scatter(x_train_np, y_train_np, c=p_exact_np, label='Exact p', marker='o')
plt.scatter(x_train_np, y_train_np, c=p_pred_np, label='Predicted p', marker='x')
plt.legend()
plt.colorbar()
plt.title('Predicted Pressure')



plt.show()

x_test = x[30:]
y_test = y[30:]
z_test = z[30:]
u_test = u_exact[30:]
v_test = v_exact[30:]
w_test = w_exact[30:]
p_test = p_exact[30:]

uvp_test = model(torch.cat((x_test, y_test, z_test), dim=1))
ut_pred = uvp_test[:,0:1]

ut_pred = ut_pred.detach().numpy()
plt.plot(u_test, label = "Exact")
plt.plot(ut_pred, label = "PINN")
plt.legend()

xx = (torch.tensor(data['x'][:], dtype=torch.float32)).reshape(-1,1)
yy = (torch.tensor(data['y'][:], dtype=torch.float32)).reshape(-1,1)
uu = (torch.tensor(data['u'][:], dtype=torch.float32)).reshape(-1,1)

uvwp_test = model(torch.cat((x, y, z), dim=1))
up = uvwp_test[:,0:1]


plt.subplots(1,1)
plt.title("Exact")
plt.tricontourf(xx.flatten(), yy.flatten(), uu.flatten(), cmap="RdBu_r")
plt.colorbar()

plt.subplots(1,1)
plt.title("PINN")
plt.tricontourf(xx.flatten(),yy.flatten(),up.detach().numpy().flatten(), cmap="RdBu_r")
plt.colorbar()
plt.show()



new_point = pd.read_csv("test_cloud1_U.csv")
new_point = (new_point - new_point.min()) / (new_point.max() - new_point.min())


new_xx = (torch.tensor(new_point['x'][:], dtype=torch.float32)).reshape(-1,1)
new_yy = (torch.tensor(new_point['y'][:], dtype=torch.float32)).reshape(-1,1)
new_zz = (torch.tensor(new_point['z'][:], dtype=torch.float32)).reshape(-1,1)

new_uu = (torch.tensor(new_point['u'][:], dtype=torch.float32)).reshape(-1,1)
new_uu = new_uu.detach().numpy()
uvwp_test = model(torch.cat((new_xx, new_yy, new_zz), dim=1))
u_new = uvwp_test[:,0:1]
u_new = u_new.detach().numpy()

plt.figure(dpi = 150)
plt.plot(new_uu, label='Exact u', marker='o')
plt.plot(u_new, label='Predicted u', marker='x')
plt.legend()
plt.title('Comparison of u component')